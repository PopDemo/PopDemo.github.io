{"pages":[],"posts":[{"title":"LomBok","text":"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 俗话说的好，授人以鱼不如授人以渔，so，我就直接将我们的LomBok的实现原理和环境说清楚哈 lombok实现原理和背景 背景 自从java6开始，javac就开始支持“JSR 269 Pluggable Annotation Processing Api”规范，也就是只要程序实现该API，就能在javac运行时得到调用 LomBok就是一个实现了“JSR 269 API”的程序，在使用javac的过程中，它产生作用的具体流程 javac对其源码进行分析，生成抽象语法树（SAT） javac编译过程中调用实现了JSR 269Api接口的LomBok注解 LomBok会对javac生成的SAT（抽象语法树）进行修改，找到lombok对应所在类的对应语法树，然后，修改语法树，添加lombok注解定义的相关树节点 javac会对修改后的抽象语法树进行生成字节码文件 LomBok使用流程 背景 因为我本身喜欢科技化的生产力工具，这里也就使用IDEA呐 流程 在idea中添加对应的插件进行使用 引入maven的依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.14&lt;/version&gt; &lt;/dependency&gt; LomBok常用注解 @Get@Set作用在类上 在给所有的成员变量生成GetSet方法,同时可以设定访问权限及是否懒加载等 @ToString 声称该类的toString方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段 @NotNull 作用于成员变量和参数！表示不能为空，否则抛出空指针 @NoArgsConstructor 生成无参构造 @AllArgsConstructor 生成全参构造 @Data 是@ToString@EqualsAndHashCode@Getter@Setter @RequiredArgsConstructor注解的集合 @Log 作用于类，生成日志变量，针对不同的日志实现，有什么不同的注解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 呐，lombok添加+使用+实现原理一步到位哈，加油各位","link":"/2020/05/06/LomBok/"},{"title":"MQ","text":"1. MQ（消息队列） 介绍 消息队列中间件是分布式系统中的重要组件，主要解决以下应用背景中的三大模块，从而实现高性能，高可用，可伸缩和最终一致性的架构 应用背景 异步消息，应用解耦，流量削峰 异步消息 当我们的用户注册后写入数据库后，需要去发送短信和邮件去通知用户 传统处理 解释 我们需要一级一级来对其进行功能的实现非常耗时 加入MQ后 解释 通过写入我们消息队列，让邮件和信息模块直接去异步读取消息队列中的祖册信息 应用解耦 用户下单后，订单系统需要通知库存系统 传统处理 解释 它通过我们的订单系统直接去访问我们的库存系统，假如我们的库存系统宕机了，那会造成很大的影响 缺点 ： 订单系统和库存系统紧密的耦合在一起 加入MQ 解释 实现应用解耦，加入了中间人——–最大的引入了消息中间件 订单系统可以通过写入消息队列，从而库存系统会去订阅也就是获取消息队列中的下单信息来对库存进行操作 流量削峰 例如秒杀，秒杀他会有大量的信息涌入进来，导致流量暴增，应用直接挂掉 用前端去加入消息队列 解释 在通过秒杀的案例来说，我们例如去抢购10个N95口罩 我们可以直接在消息队列中设置请求的队列的数量（=10），假如消息队列长度超过最大数量，则直接抛弃用户请求或直接跳到错误页面 之后秒杀业务处理再去获取用户的下单信息来进行完成 消息队列的两种模式 点对点模式（一对一模式，消费者主动拉去数据，消息收到后消息清除） 发布-订阅模式（一对多，消费者消费数据之后不会清楚消息） 消息生产者（发布）消息发布到topic主题中，同时有多个消息消费者（订阅）消费该消息，和点对点的方式不同，发布到topic的消息会被所有的订阅者消费 谈谈对于两种模式的优缺点 点对点 缺点 我们需要消费者 主动的去 队列中去找到消息，so 我们的消费者需要 不停的去 队列中去查看消息 发布-订阅模式 缺点 我们的主题队列会主动的去把消息推到消费者里，但是我们的消费者可能会 被动接收到 更大的流量，造成宕机，或者 消费者的处理量很大，又会造成资源浪费 优点 消息队列可以传给多个消费者来进行使用 消费者的消费速度，可以自己去设置使用","link":"/2020/03/24/MQ/"},{"title":"Python的基础语法的总结","text":"Python基础语法（认真学习的猿,才能的到最后的果实!）==============一，格式化常用的占位符1.“%”运算符就是用来格式化字符串的2.如果字符串中要表示%的时候必须打%%3.格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换符串内的占位符{0}、{1}……4.在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。5.死知识 占位符——————– 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数二，格式 1.在多个格化式字符中要把参数放进print（）括号里面 %.1f 这个意思就是去小数点后一位 在控制台输入的东西要是int类型的时候必须要（s1=int(input(“请输入你要加入的数字”)) 三，list集合 ​ 0.可以把元素插入到指定的位置，比如索引号为1的位置： classmates.insert(1, ‘Jack’)classmates[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’, ‘Adam’] ​ 1.要删除list末尾的元素，用pop()方法 ​ classmates.pop() ‘Adam’classmates [‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’] ​ 2.删除指定位置的元素，用pop(i)方法，其中i是索引位置： classmates.pop(1) ‘Jack’classmates[‘Michael’, ‘Bob’, ‘Tracy’]4.append追加，会将追加的东西作为一个整体追加，5.extend是保持原有格式的扩展,将其变成单个字符添加。6.count(关键字) 统计关键字的个数 ​ 3.insert(‘索引位置’,添加的值) 四，Tuple 有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改 当然也有可变元组（即元组里面有列表） 五，If while 循环 range()，可以生成一个整数序列 例：range(5)生成的序列是从0开始小于5的整数：2.Continue 可以跳过当前循环 例： 六，dict(不可变元素)全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储 1 .要删除一个key，用pop(key)方法，对应的value也会从dict中删除​ &amp;&amp;​ 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。​ 和list比较，dict有以下几个特点：​ 1.查找和插入的速度极快，不会随着key的增加而变慢；​ 2.需要占用大量的内存，内存浪费多。​ 而list相反：​ 1.查找和插入的时间随着元素的增加而增加；​ 2.占用空间小，浪费内存很少。​ 所以，dict是用空间来换取时间的一种方法七，Set(不可变元素) set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。2.重复元素在set中自动被过滤： 例: 3.通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：4.通过remove(key)方法可以删除元素：5.replace()方法①，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。②，所以这个方法就是不会在原有的对象上做手脚，只会赋到新的元素当中（同时也就保证了不可变对象本身永远是不可变的） +++++1+++++不可变对象。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：八，函数 绝对值函数abs(参数) max函数（可以接收任意多个参数，并返回最大的那个） 数据类型转换 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”a=abs //a现在是一个abs绝对值函数类型a=(-1) 九，定义函数 定义函数时，需要确定函数名和参数个数；如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果，函数执行完毕也没有return语句时，自动return None。函数可以同时返回多个值，但其实就是一个tuple。 2.import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 附上本人所有对于python基础的全部总结,纯干货呦！（包括爬虫等等） 123链接：https://pan.baidu.com/s/1AZZcoEP6F2PRBgg_qfWK5A 提取码：yzyk 以上全是是自己总结新手博主—以上有很多空格的就是有图片（本人很努力的在学习MD语法）12345678参考：[廖雪峰][www.liaoxuefeng.com]附语：廖老师的网站是很适合小白的，本人有一点java的基础下学Python 要有方向的努力！！！《很重要》 还是那句话基础不牢地动山摇！！！","link":"/2020/02/06/Python%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/"},{"title":"ActiveMQ","text":"1. JMS消息模型 即 java Message service P2P(Point to Point) 点对点模式 P2P模式包含三个角色 消息队列（Queue） 发送者（Sender） 接收者（Receiver） 解释: ​ 每个消息都被发送到一个特定的队列，接收者从队列中获取消息，队列保留着消息，直到它们被消费或超时 P2P的特点 每个消息只能有一个消费者（即一旦被消费，消息就不在队列中） 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，他都不会影响到消息被发送到队列中（在时间上没有依赖性） 接收者在成功接受消息之后需向队列应答成功 so 如果希望发送的每一个消息都会被成功处理的话，那么需要P2P模式 发布订阅模式 Publish/Subscribe(Pub/Sub) 包含三个角色 主题（Topic） 发布者（Publisher） 订阅者（Subscricber） 特点 每个消息可以有多个消费者 发布者和订阅者之间有时间上的依赖性。针对每个主题（Topic）的订阅者，它必须创建一个订阅之后，才能消费发布者的消息 为了消费消息，订阅者必须保持运行的状态 so 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样,即使订阅者没有被激活（运行），它也能接受到发布和的消息 如果希望发送的消息可以被多个消费者处理的话，那么可以采用Pub和Sub模型 2. ActiveMQ Topic 消息失败重发 即是我们的消息的接收方，没有成功的消费消息，我们要去要去重发这个消息，让我们的消费者可以消费到这个消息，这个机制就是我们的重发 JMS消息确认机制 在Session中需要定义几个常量 AUTO_ACKNOWLEDGE = 1 //自动确认 CLIENT_ACKNOWLEDGE = 2 //客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 //自动批量确认 SESSION_TRANSACTED = 0 //事务提交并确认 代码确认 地址 ActiveMQ Topic 消息持久化订阅 持久化到文件（默认） 在Conf文件夹中,查看是否有 123&lt;persistenceAdapter&gt; &lt;kahaDB directory=\"${activemq.data}/kahadb\"/&gt; &lt;/persistenceAdapter&gt; ​ 持久化到数据库（mysql数据库）","link":"/2020/04/16/ActiveMQ/"},{"title":"maven初识","text":"maven&emsp;&emsp;随着时间的磨逝，我离我的职业生涯有更进了一步，最近开整了maven这个爸爸，来进行整理我的项目，使我的项目更加的整齐，同时我也可以同过maven的分模块进行编译我们java后端的三个老大哥，接下来分享一下如何安装以及去使用分模块的maven &emsp;一.安装&emsp;&emsp;&emsp;1：需要准备的东西&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;① JDK &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;②IDEA（以最智能的IDEA为主题） &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;③Maven程序安装包 &emsp;&emsp;&emsp; 2. 前往https://maven.apache.org/download.cgi下载最新版的Maven程序： &emsp;&emsp;&emsp; 3.将文件解压到D:\\Program Files\\Apache\\maven目录下: &emsp;&emsp;&emsp;&emsp; 4.新建环境变量MAVEN_HOME，赋值D:\\Program Files\\Apache\\maven &emsp;&emsp;&emsp;&emsp; 5.编辑环境变量Path，追加%MAVEN_HOME%\\bin; &emsp;&emsp;&emsp;&emsp; 6.至此，maven已经完成了安装，我们可以通过DOS命令检查一下我们是否安装成功： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这样maven的环境就ok了 &emsp;二.创建maven项目&emsp;&emsp;&emsp;&emsp; 1.选择webapp骨架 &emsp;&emsp;&emsp;&emsp;2.配置maven 的GAV &emsp;&emsp;&emsp;&emsp;3.配置你的本地的maven库 &emsp;&emsp;&emsp;3.配置你的本地的maven库 &emsp;&emsp;&emsp;&emsp;4.最后一步———-&gt;进行false，创建完成 ###&emsp;三.你的maven项目全部文件解析(这个md没有编译过来布吉岛为什么) &emsp;四.maven多模块思想&emsp;&emsp;&emsp;&emsp;1.概念！ &emsp;&emsp;&emsp;&emsp;&emsp;继承：创建一个parent工程将所需的依赖都配置在pom中 &emsp;&emsp;&emsp;&emsp;&emsp;聚合：聚合多个模块运行 &emsp;&emsp;&emsp;&emsp;2.流程 &emsp;&emsp;&emsp;&emsp;&emsp;2-1：1. 需求拆分 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Dao service（zip） web &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;何为继承：继承就是为了消除重复 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;何为聚合：项目开发通常是分组模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行 &emsp;五，创建步骤&emsp;&emsp;&emsp;1.创建父工程 ​ &emsp;&emsp;&emsp;&emsp;2.将父工程发布至仓库 ​ &emsp; &emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 3.创建dao子模块(各模块只放和自己相关代码注意：选择骨架直接下一步！来进行编译子模块) &emsp;&emsp;&emsp;&emsp; 4.测试 &emsp;&emsp;&emsp;&emsp; 上图报错的解决办法（将新建的模块 调至一样的JDK版本） &emsp;&emsp;&emsp;&emsp;5.发布模块至本地仓库 ) &emsp;&emsp;&emsp;&emsp;6.创建Biz子模块（注意：选择骨架直接下一步！来进行编译子模块） &emsp;&emsp;&emsp;&emsp;7.创建Web模块 &emsp;&emsp;&emsp;&emsp;&emsp;7-1 .同时右击创建 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;7-2.选择web-app的骨架来进行创建 &emsp;附：maven管理的SSM项目的pom.xml文件解析&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project()xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目解释--&gt; &lt;groupId&gt;cn.popdemo&lt;/groupId&gt; &lt;artifactId&gt;maven_Demo01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;maven_Demo01 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&apos;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!--项目配置版本--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!--项目依赖的jar包--&gt; &lt;dependencies&gt; &lt;!--test测试的包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet-api的包（httprequest和respones中里使用）--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--2. SpringDAO层依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--springWeb的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis整合spring的适配包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库驱 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!--EL表达式--&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl页面的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;maven_Demo01&lt;/finalName&gt; &lt;resources&gt; &lt;!--指定xml文件位置--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*/.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--这里写成true会造成编译注释错误--&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lockdown plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- seehttp://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!-- tomcat插件控制 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!--端口控制--&gt; &lt;port&gt;8060&lt;/port&gt; !--项目路径控制意味着http://localhost:8080/abc-- &lt;path&gt;/abc&lt;/path&gt; &lt;!--编码--&gt;UTF-8 &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- maven插件控制 --&gt; &lt;plugin&gt;org.apache.maven.plugins maven-compiler-plugin 3.1 &lt;configuration&gt;1.8 1.8 utf-8 &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; s`","link":"/2020/02/25/maven%E5%88%9D%E8%AF%86/"},{"title":"Protobuf","text":"特点 使用 编写流程 先编译要序列的实体属性到Protot文件中 User.proto文件 123456789101112//生成我们的java地址option java_package=\"cn.popdemo.protobuf\";//生成java文件名option java_outer_classname=\"UserSerializer\";//对应其序列化类的属性//每个属性都有个人的IDmessage User{required int64 id = 1;required string userName = 2;required string userPassword = 3;required int64 money = 4;} ​ 使用Google的工具包对其进行编译为java文件 生成批处理结合工具包生成java文件 protoc ./User.Proto –java_out=./ pause 将生成后的java文件放置到项目中的Protobuf文件中 添加Protobuf依赖 &lt;!-- protobuf --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738 - 编写序列化过程（也就是↓） - 序列化过程 - &gt; ```javapublic static void main(String[] args) throws InvalidProtocolBufferException { //接受序列化后的byte字节 //并进行输出 byte[] bt = serialize(); System.out.println(Arrays.toString(bt)); //接收到byte并进行反序列化到实体 UserSerializer.User user = Notserialize(bt); System.out.println(user.getId()); System.out.println(user.getUserName()); System.out.println(user.getUserPassword()); System.out.println(user.getMoney());}//protobuf序列化private static byte[] serialize(){ //构造序列化器builder来构造我们的User Builder builder = UserSerializer.User.newBuilder(); //构造User builder.setId(1).setUserName(&quot;PopDemo&quot;).setUserPassword(&quot;123123&quot;).setMoney(1629); //生成序列实体 UserSerializer.User user = builder.build(); //进行序列化并返回byte（字节） byte[] bt = user.toByteArray(); return bt;}//protobuf反序列化private static UserSerializer.User Notserialize(byte[] bt) throws InvalidProtocolBufferException { //使用返回的byte进行反序列化到User UserSerializer.User user = UserSerializer.User.parseFrom(bt); return user;} ​","link":"/2020/04/16/Protobuf/"},{"title":"linux终端常用的命令","text":"前言​ 最近在学linux,同时整理出来些在终端常用的命令（对于文件和目录还有压缩等等） 小Demo Clear：清除当前终端所有消息 Pwd：显示当前所在目录**** 如果说没有权限时—前面加上sudo（用管理员身份运行此命令） 递归:包括全部的文件夹以及该文件夹里的所有目录 正文——​ 一．目录跳转 ​ cd usr 切换到该目录下usr目录 ​ cd ../ 切换到上一层目录 ​ cd / 切换到系统根目录 ​ cd ~ 切换到用户主目录 ​ cd - 切换到上一个所在目录 ​ ls 查看目录 ​ ls -a 查询出所有文件目录（包括隐藏的目录） ​ la -l （同== ll（小写L））可以查看所有文件及目录的所有详细信息（包括时间..等等） ​ 二．文档目录的操作 mkdir 文件名 模糊查找文件 ​ find -name ‘你要查找的文件夹’(注意要加‘ 单引号 和 *) 修改文件夹名称—（同时可以对压缩包目录修改名称） ​ mv ‘就文件夹名称’ ‘新文件夹名称’ 4.删除文件 ​ Rm -f 文件夹或目录 5.移动目录位置 ​ Mv ‘旧文件夹名称’‘旧文件夹新目录‘ 拷贝目录 ​ Cp -r 目录名称 目录拷贝的目标位置 ​ Cp -rf 目录名称 目录拷贝的目标位置（cp递归复制所有文件以及目录） 三．对于CentOS系统操作 ​ reboot 立刻重启 ​ shutdown –r now 立刻重启 ​ shutdown –r 10 10分钟后重启 四．对于文本txt ​ 1.创建一个txt可编辑文件 ​ Touch 文本名.txt ​ 2.cat/more/less/tail（四种查看文档的方式） ​ cat:只能显示最后一页的内容 ​ More：more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容。 使用空格键或回车键向下翻页 “q”退出查看 ​ less：通过上下键paup来进行查看文档“q”退出 ​ tail –‘行数’可以查看第几行的内容 ​ 文档名成 tail –‘行数‘ 3.修改文档内容 ​ vim 文档名称 ​ ① ：进去后会进入命令模式—输入：（a：末尾添加 i：当前光标添加 ） ​ 3-1：退出保存文档流程 ​ ESC退出修改文档内容模式-à进入命令模式-à输入：（进行保存操作）à①保存退出 ​ 在冒号内输入wq（来进行对修改后的文档内容进行保存） ​ ② 不想保存 ​ 在冒号内输入q（取消保存） 五：压缩文件的操作命令（打包压缩同时进行） 打包压缩文件 ​ tar -zcvf 打包压缩后的文件名 要压缩的文件名称及后缀 ​ 其中：z:调用gzip来进行压缩 ​ c:打包文件 ​ v:显示运行过程 ​ f:指定的文件名 解压-压缩包 ​ Tar -xvf 要解压的压缩包名称及后缀 ​ 3．解压到目的地 ​ ①Tar -xvf 压缩文件和后缀 -c /指定的位置 ​ -c：解压到 ​ ②： unzip 要解压的解压包 -d 解压到的地址 六：搜索关键字 六：搜索关键字 1．grep 搜索目标文件中的字符的行,来进行显示 ​ grep 字符 目标文件 七：管道命令 ​ 命令： | ​ 理解: 将上一次命令的输出作为本次命令的输入 八：进程命令 ps -ef（查看系统的进程） kill -9 结束进程的id（强制结束进程）","link":"/2020/02/12/linux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"title":"关于爬虫的流程和原理","text":"一． 爬取数据流程（Reptile） 1.在网页中找到类似于url=’http://www.7799520.com/api/user/pc/list/search?marry=1&amp;page=9' ​ 这种的网站会给我们返回一个类似于元组的数据来进行 2.requests.get(“地址”) 这个后的get是通过你当前网页的提交方式来进行决定 3.通过“键”找到对应的值来获取到自己想要的数据 4.你拿到的值是“字典“格式，所以当你在放入文档时必须要转换为集合的格式 123456789101112131415item = [ dat.get('userid'), dat.get('province'), dat.get('city'), dat.get('height'), dat.get('username'), dat.get('monolog'), ] 4-1：使用更快捷更ok 的方法 ​ //这里的*也可以称之为解包，也就是去除 [ ] 这个外壳来获取到值 Item = [*dat.value] save_test = (Str(item)）//转换为Str格式，之后进入传入文档 二．将爬取的数据放置在文档内 1.通过函数的方式进行获取到值， defsave_test(dat): 然后with也就是操作系统文档，然后不使用时，自动close​ withopen(‘DemoByJson.test’,’a’,encoding=’utf-8’) as f:​ f.write(dat+”\\n”) 2 ．最重要的“点” 12345if __name__ == '__main__': jsondata = getJson() param(jsondata) 你不是使用这个判定系统不会进入你的函数内 1If __name__ == '__main__': 这里的意思是：​ 当你当前这个py文件进行编译时，也就是当前的name已经改编为main，也就是你当前这个文件编译中！！！！","link":"/2020/02/10/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/"},{"title":"从&#39;0&#39;到微服务框架","text":"微服务 理解 背景 从头开发的网上超市！ 当时 网站： 用户注册、登录功能 商品展示 下单 总体架构图 时间（变化）轴 故事 小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据 随着时代，用户增长，渐渐发生—— 知识点简介 抽象出公共服务 理解 也就是抽象出公用的业务能力，来做成公共服务 图 烟囱式系统 缺点 数据库成为性能瓶颈，并且有单点故障的风险。 数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。 数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整 监控—–发现故障的征兆 实现步骤 微服务架构中组件繁多，各个组件所需要监控的指标不同 比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等 因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差 so↓ 一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。 最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警 定位问题——链路跟踪 理解 通过链路跟踪的方式来对用户调用某个服务时查看所调用的全部接口或服务，另外还需要调用日志收集与存储的组件，以展示链路调用的UI组件 这里的UI组件 请查找答案 网关—权限控制，服务治理 背景 拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的 经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据…… 解决调用错误接口服务 so,微服务的调用需要一个把关的东西，也就是网关 在调用者和被调用者中间加入一层网关，每次调用都会进入权限校验，同时，网关可以作为一个提供服务接口文档的平台 使用网关的粒度 最粗力度 指整个微服务一个网关， 最细粒度 则是所有调用，不管是微服务内部，调用过着来自外部服务的调用，都要通过网关 折中方案 按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用 熔断，服务降级，限流 熔断 理解 当一个服务因为各种原因停止响应时，调用方通常会等待一段时间或者收到了错误返回 如果调用链路必将长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游（也就是基层）的响应， so 当我们多次访问一个服务失败时，我们应该熔断，标记该服务已停止工作 服务降级 背景 当下游的服务停止工作后，如果该服务并非核心业务，则上有服务应该降级，以保证核心业务不中断 实例 网上超市的下单页面有一个推荐商品凑单的功能，当该模块挂了后，只需要暂时关闭推荐功能即可 限流 当一个服务挂掉后，用户会习惯性的进行重复访问，，这导致一旦服务恢复正常很可能瞬间error so 服务里需要自我保护–也就是限流， 限流的策略有很多 当单位时间内请求次数过多，丢弃多余的请求， 考虑分区限流。仅拒绝来自产生大量请求的服务的请求 例如商品服务和订单服务都需要访问促销服务 商品服务由于代码问题发起了大量请求 促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应 ​ 总结 微服务框架 引入组件以及功能 指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码 如果让每个应用服务自己实现是非常耗时耗力的 so 基于DRY的原则，便有了我们现在如火如荼的微服务框架 将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发 自定义的功能 代码级的链路跟踪 甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态 缺点 框架更新成本很高 每次框架升级，都需要所有应用服务配合升级 当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级 so 因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范 ​","link":"/2020/03/16/%E4%BB%8E'0'%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"},{"title":"关于java的垃圾处理机制","text":"首先说java的垃圾回收机制 简述垃圾回收机制 在java中程序员不用去显示性的去释放一个对象的内存，而是由虚拟机去自行执行 在jvm中，垃圾回收是低优先级的，所以不会在一般的情况下去运行，而实在jvm空闲的时候或者是堆空间满了的时候，才会触发执行 可以通过可达性的方式来对没有引用的对象进行一个垃圾处理的行为 缺点 java的垃圾回收机制是自动化的，可控性很差，有时会出现内存溢出的情况 再说说—java是如何确定哪些对象应该进行回收 对象被回收的两个经典算法 引用计数法 就是用来记录对象被 引用 的次数 实现方式 给对象添加上一个引用计数器， 当该对象被调用时，我们的计数器+1， 当该引用失效时，我们的计数器就会-1，当 某一个对象的引用计数器为0时，那就说明表示这个对象没有人进行引用，那就意味着它是一个失效的垃圾对象，就会被GC处理进行回收！ 缺点 这种简单的算法jvm并没有进行使用，原因是她不能解决对象间相互调用引用的问题 假设有A和B两个对象之间互相引用，也就是说A对象中的一个属性是B，B中的一个属性时A,这种情况下由于他们的相互引用，从而是垃圾回收机制无法识别 可达性分析算法 通过判断对象的引用链是否可达来进行决定对象是否进行回收 实现方式 从离散数学中的图论引入的，我们会把程序看作一张图 通过一系列的名为GC Roots的对象作为起始点 从这些节点开始向下搜索，搜索所走过的路径成为引用链 当我们一个对象到我们的GCRoot没有任何的引用链进行连接时（就是从GCRoot到这个对象不可达） 则证明此对象时不可用的，就会进行GC处理 再说说- 什么时候进行回收 在CPU空闲的时候进行回收 在堆空间储存满了之后 主动调用System.Gc()后尝试进行回收 如何回收—回收工作原理 也就是说的垃圾收集的算法 标记–清除算法（最基础的一种算法） 实现步骤 一个步骤也就是标记出需要回收的对象 标记完成后就进行同一个回收掉那些带有标记的对象 缺点 空间问题 当我们标记后进行清除后，会产生大量不连续的内存碎片 再分配 当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而造成内存空间浪费 复制算法 实现步骤 我们通过将可用的内存按容量划分为大小相等的两块，每次只去使用其中的一块 但我们这一块的内存用完了，就将还存活着的对象复制到另一块的内存上面 然后再将已使用过的内存空间一次清理掉，这样使得每次都是对其中的一块进行内存回收GC 缺点 在对其对象存活率较高时就要执行较多的复制操作时，我们的效率就会降低 更关键的是—–浪费了一半的空间 标记整理算法 实现步骤 对其需要回收的对象进行标记 然后对其标记的回收对象进行回收 与标记清楚算法进行比较 标记清楚算法仅对不存活的对象进行处理，剩余存活对象不做任何处理，造成内存碎片 而标记整理算法，不仅对不存活的对象进行处理，同时还对剩余的存活对象进行整理，重新整理 so 不会产生内存碎片 分代收集算法 理解 这种算法是一种比较智能的算法，也就是现在jvm使用最多的一种算法 算法策略 他会在具体的场景自动选择以上三种算法进行垃圾对象回收 垃圾回收的各个场景和相应回收策略","link":"/2020/04/10/%E5%85%B3%E4%BA%8Ejava%E7%9A%84%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"title":"属于PopDemo的第一篇文章","text":"PopDemo给自己的一段话：首先庆祝自己获得第一个博客，虽然寄托在Github旗下，但是已经非常不错了 加油，继续努力！ 相信自己！你要继续学习的语言 JAVA Python(继续学习一下Scrapy框架) VUE(学习基础)给自己和来者的一句话基础不牢，地动山摇！！！","link":"/2020/02/02/%E5%B1%9E%E4%BA%8EPopDemo%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"序列化介绍和使用","text":"序列化 什么是序列化 就是把java对象储存在某一地方（硬盘,网络），也就是将对象的内容流化 两大类 序列化 将数据分解成字节流，一边存储在文件中或在网络上传输 反序列化 打开字节流并重构对象，对象序列化不仅要将基本数据类型转换成字节表示,有时还要恢复数据， 常用的序列化 java中自带的序列化技术 IOException** Serializable接口，则所有的序列化将会自动进行 Externalizable 则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量 json 定义 是一种轻量级的数据交换格式,采用与编程语言无关的文本格式 优缺点 优点 数据格式比较简单，易于读写 序列化后数据较小，可扩展性好，兼容性好 缺点 数据的描述性不乐观 Fastjson 定义 FastJson是一个java语言编写的高性能功能完善的JSON库 优缺点 优点 接口简单易用 目前java语言中最快的json库 缺点 过于注重快，而偏离了“标准”及功能性 代码质量不高，文档不全 Protobuf 定义 protobuf是可以进行跨语言的序列化机制 优缺点 优点 性能强 结构化数据存储格式（XML JSON等） 缺点 需要依赖于工具生成代码 如何进行序列化 让类实现Serializable接口 该接口是一个标志性的接口,标注该类可被序列 然后使用输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出 如果需要反序列化,则可以用一个输入流建立对象输入流,然后通过readObject方法从流中读取对象 代码 序列化User到本地 @Test public void Test01() throws IOException { //获取文件的输出流inputStream //将这个对象输出 User user1 = new User(1,\"PopDemo\",\"1234567\"); User user2 = new User(2,\"yangfan\",\"1234567\"); User user3 = new User(3,\"iu\",\"1234567\"); /** * 与这个文件的输出流进行绑定操作 * 我们利用这个对象的输出流，然后进行写一个操作 * 就可以实现对象的序列化的过程 * 建立管道 * 进行输出实体 */ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"F:/pop.txt\")); //讲类输出到管道内 oos.writeObject(user1); oos.writeObject(user2); oos.writeObject(user3); oos.flush(); oos.close(); System.out.println(\"数据已保存到本地，感谢您的使用\"); } &lt;!--￼0--&gt; transient 和 static 为什么不会被序列化的原因 transient static不会被序列化(IOException) 序列化保存的是对象的状态，静态变量数以类的状态，因此序列化并不保存静态变量。 这里的不能序列化的意思，是序列化信息中不包含这个静态成员域 但是还有一种情况会被序列化 One 当我们实现Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关","link":"/2020/04/02/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"LomBok","slug":"LomBok","link":"/tags/LomBok/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"java垃圾处理机制","slug":"java垃圾处理机制","link":"/tags/java%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"}],"categories":[]}