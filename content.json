{"pages":[],"posts":[{"title":"LomBok","text":"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 俗话说的好，授人以鱼不如授人以渔，so，我就直接将我们的LomBok的实现原理和环境说清楚哈 lombok实现原理和背景 背景 自从java6开始，javac就开始支持“JSR 269 Pluggable Annotation Processing Api”规范，也就是只要程序实现该API，就能在javac运行时得到调用 LomBok就是一个实现了“JSR 269 API”的程序，在使用javac的过程中，它产生作用的具体流程 javac对其源码进行分析，生成抽象语法树（SAT） javac编译过程中调用实现了JSR 269Api接口的LomBok注解 LomBok会对javac生成的SAT（抽象语法树）进行修改，找到lombok对应所在类的对应语法树，然后，修改语法树，添加lombok注解定义的相关树节点 javac会对修改后的抽象语法树进行生成字节码文件 LomBok使用流程 背景 因为我本身喜欢科技化的生产力工具，这里也就使用IDEA呐 流程 在idea中添加对应的插件进行使用 引入maven的依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.14&lt;/version&gt; &lt;/dependency&gt; LomBok常用注解 @Get@Set作用在类上 在给所有的成员变量生成GetSet方法,同时可以设定访问权限及是否懒加载等 @ToString 声称该类的toString方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段 @NotNull 作用于成员变量和参数！表示不能为空，否则抛出空指针 @NoArgsConstructor 生成无参构造 @AllArgsConstructor 生成全参构造 @Data 是@ToString@EqualsAndHashCode@Getter@Setter @RequiredArgsConstructor注解的集合 @Log 作用于类，生成日志变量，针对不同的日志实现，有什么不同的注解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 呐，lombok添加+使用+实现原理一步到位哈，加油各位","link":"/2020/05/06/LomBok/"},{"title":"ActiveMQ","text":"1. JMS消息模型 即 java Message service P2P(Point to Point) 点对点模式 P2P模式包含三个角色 消息队列（Queue） 发送者（Sender） 接收者（Receiver） 解释: ​ 每个消息都被发送到一个特定的队列，接收者从队列中获取消息，队列保留着消息，直到它们被消费或超时 P2P的特点 每个消息只能有一个消费者（即一旦被消费，消息就不在队列中） 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，他都不会影响到消息被发送到队列中（在时间上没有依赖性） 接收者在成功接受消息之后需向队列应答成功 so 如果希望发送的每一个消息都会被成功处理的话，那么需要P2P模式 发布订阅模式 Publish/Subscribe(Pub/Sub) 包含三个角色 主题（Topic） 发布者（Publisher） 订阅者（Subscricber） 特点 每个消息可以有多个消费者 发布者和订阅者之间有时间上的依赖性。针对每个主题（Topic）的订阅者，它必须创建一个订阅之后，才能消费发布者的消息 为了消费消息，订阅者必须保持运行的状态 so 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样,即使订阅者没有被激活（运行），它也能接受到发布和的消息 如果希望发送的消息可以被多个消费者处理的话，那么可以采用Pub和Sub模型 2. ActiveMQ Topic 消息失败重发 即是我们的消息的接收方，没有成功的消费消息，我们要去要去重发这个消息，让我们的消费者可以消费到这个消息，这个机制就是我们的重发 JMS消息确认机制 在Session中需要定义几个常量 AUTO_ACKNOWLEDGE = 1 //自动确认 CLIENT_ACKNOWLEDGE = 2 //客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 //自动批量确认 SESSION_TRANSACTED = 0 //事务提交并确认 代码确认 地址 ActiveMQ Topic 消息持久化订阅 持久化到文件（默认） 在Conf文件夹中,查看是否有 123&lt;persistenceAdapter&gt; &lt;kahaDB directory=\"${activemq.data}/kahadb\"/&gt; &lt;/persistenceAdapter&gt; 持久化到数据库（mysql数据库）","link":"/2020/04/16/ActiveMQ/"},{"title":"Protobuf","text":"特点 使用 编写流程 先编译要序列的实体属性到Protot文件中 User.proto文件 123456789101112//生成我们的java地址option java_package=\"cn.popdemo.protobuf\";//生成java文件名option java_outer_classname=\"UserSerializer\";//对应其序列化类的属性//每个属性都有个人的IDmessage User{required int64 id = 1;required string userName = 2;required string userPassword = 3;required int64 money = 4;} - 使用Google的工具包对其进行编译为java文件 - &gt; 生成批处理结合工具包生成java文件 &gt; &gt; protoc ./User.Proto --java_out=./ &gt; &gt; pause - 将生成后的java文件放置到项目中的Protobuf文件中 - ![img](http://m.qpic.cn/psc?/V12figq01webP8/Af1yGqSdppVqA7I0*cpgDF1YeBJTQhI6D0h0EG5HfpVuVNcnUQWdGOeH6kb80Vd9SK5CbMdUdGlLnsLSZxfg8f1eipjWCVL2dNjKVuvH0tk!/b&amp;bo=QALBAQAAAAADF7A!&amp;rf=viewer_4) - 添加Protobuf依赖 - &gt; ``` &gt; &lt;!-- protobuf --&gt; &gt; &lt;dependency&gt; &gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &gt; &lt;version&gt;3.7.1&lt;/version&gt; &gt; &lt;/dependency&gt; &gt; 1234567891011121314151617181920212223242526272829303132333435363738 - 编写序列化过程（也就是↓） - 序列化过程 - &gt; ```javapublic static void main(String[] args) throws InvalidProtocolBufferException { //接受序列化后的byte字节 //并进行输出 byte[] bt = serialize(); System.out.println(Arrays.toString(bt)); //接收到byte并进行反序列化到实体 UserSerializer.User user = Notserialize(bt); System.out.println(user.getId()); System.out.println(user.getUserName()); System.out.println(user.getUserPassword()); System.out.println(user.getMoney());}//protobuf序列化private static byte[] serialize(){ //构造序列化器builder来构造我们的User Builder builder = UserSerializer.User.newBuilder(); //构造User builder.setId(1).setUserName(&quot;PopDemo&quot;).setUserPassword(&quot;123123&quot;).setMoney(1629); //生成序列实体 UserSerializer.User user = builder.build(); //进行序列化并返回byte（字节） byte[] bt = user.toByteArray(); return bt;}//protobuf反序列化private static UserSerializer.User Notserialize(byte[] bt) throws InvalidProtocolBufferException { //使用返回的byte进行反序列化到User UserSerializer.User user = UserSerializer.User.parseFrom(bt); return user;}","link":"/2020/04/16/Protobuf/"},{"title":"MQ","text":"1. MQ（消息队列） 介绍 消息队列中间件是分布式系统中的重要组件，主要解决以下应用背景中的三大模块，从而实现高性能，高可用，可伸缩和最终一致性的架构 应用背景 异步消息，应用解耦，流量削峰 异步消息 当我们的用户注册后写入数据库后，需要去发送短信和邮件去通知用户 传统处理 解释 我们需要一级一级来对其进行功能的实现非常耗时 加入MQ后 解释 通过写入我们消息队列，让邮件和信息模块直接去异步读取消息队列中的祖册信息 应用解耦 用户下单后，订单系统需要通知库存系统 传统处理 解释 它通过我们的订单系统直接去访问我们的库存系统，假如我们的库存系统宕机了，那会造成很大的影响 缺点 ： 订单系统和库存系统紧密的耦合在一起 加入MQ 解释 实现应用解耦，加入了中间人——–最大的引入了消息中间件 订单系统可以通过写入消息队列，从而库存系统会去订阅也就是获取消息队列中的下单信息来对库存进行操作 流量削峰 例如秒杀，秒杀他会有大量的信息涌入进来，导致流量暴增，应用直接挂掉 用前端去加入消息队列 解释 在通过秒杀的案例来说，我们例如去抢购10个N95口罩 我们可以直接在消息队列中设置请求的队列的数量（=10），假如消息队列长度超过最大数量，则直接抛弃用户请求或直接跳到错误页面 之后秒杀业务处理再去获取用户的下单信息来进行完成 消息队列的两种模式 点对点模式（一对一模式，消费者主动拉去数据，消息收到后消息清除） 发布-订阅模式（一对多，消费者消费数据之后不会清楚消息） 消息生产者（发布）消息发布到topic主题中，同时有多个消息消费者（订阅）消费该消息，和点对点的方式不同，发布到topic的消息会被所有的订阅者消费 谈谈对于两种模式的优缺点 点对点 缺点 我们需要消费者 主动的去 队列中去找到消息，so 我们的消费者需要 不停的去 队列中去查看消息 发布-订阅模式 缺点 我们的主题队列会主动的去把消息推到消费者里，但是我们的消费者可能会 被动接收到 更大的流量，造成宕机，或者 消费者的处理量很大，又会造成资源浪费 优点 消息队列可以传给多个消费者来进行使用 消费者的消费速度，可以自己去设置使用","link":"/2020/03/24/MQ/"},{"title":"Python的基础语法的总结","text":"Python基础语法（认真学习的猿,才能的到最后的果实!）==============一，格式化常用的占位符1.“%”运算符就是用来格式化字符串的2.如果字符串中要表示%的时候必须打%%3.格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换符串内的占位符{0}、{1}……4.在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。5.死知识 占位符——————– 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数二，格式 1.在多个格化式字符中要把参数放进print（）括号里面 %.1f 这个意思就是去小数点后一位 在控制台输入的东西要是int类型的时候必须要（s1=int(input(“请输入你要加入的数字”)) 三，list集合 ​ 0.可以把元素插入到指定的位置，比如索引号为1的位置： classmates.insert(1, ‘Jack’)classmates[‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’, ‘Adam’] ​ 1.要删除list末尾的元素，用pop()方法 classmates.pop() ‘Adam’classmates [‘Michael’, ‘Jack’, ‘Bob’, ‘Tracy’] ​ 2.删除指定位置的元素，用pop(i)方法，其中i是索引位置： classmates.pop(1) ‘Jack’classmates[‘Michael’, ‘Bob’, ‘Tracy’]4.append追加，会将追加的东西作为一个整体追加，5.extend是保持原有格式的扩展,将其变成单个字符添加。6.count(关键字) 统计关键字的个数 ​ 3.insert(‘索引位置’,添加的值) 四，Tuple 有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改 当然也有可变元组（即元组里面有列表） 五，If while 循环 range()，可以生成一个整数序列 例：range(5)生成的序列是从0开始小于5的整数：2.Continue 可以跳过当前循环 例： 六，dict(不可变元素)全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储 1 .要删除一个key，用pop(key)方法，对应的value也会从dict中删除​ &amp;&amp;​ 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。​ 和list比较，dict有以下几个特点：​ 1.查找和插入的速度极快，不会随着key的增加而变慢；​ 2.需要占用大量的内存，内存浪费多。​ 而list相反：​ 1.查找和插入的时间随着元素的增加而增加；​ 2.占用空间小，浪费内存很少。​ 所以，dict是用空间来换取时间的一种方法七，Set(不可变元素) set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。2.重复元素在set中自动被过滤： 例: 3.通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：4.通过remove(key)方法可以删除元素：5.replace()方法①，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。②，所以这个方法就是不会在原有的对象上做手脚，只会赋到新的元素当中（同时也就保证了不可变对象本身永远是不可变的） +++++1+++++不可变对象。这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：八，函数 绝对值函数abs(参数) max函数（可以接收任意多个参数，并返回最大的那个） 数据类型转换 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”a=abs //a现在是一个abs绝对值函数类型a=(-1) 九，定义函数 定义函数时，需要确定函数名和参数个数；如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果，函数执行完毕也没有return语句时，自动return None。函数可以同时返回多个值，但其实就是一个tuple。 2.import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 附上本人所有对于python基础的全部总结,纯干货呦！（包括爬虫等等） 123链接：https://pan.baidu.com/s/1AZZcoEP6F2PRBgg_qfWK5A 提取码：yzyk 以上全是是自己总结新手博主—以上有很多空格的就是有图片（本人很努力的在学习MD语法）12345678参考：[廖雪峰][www.liaoxuefeng.com]附语：廖老师的网站是很适合小白的，本人有一点java的基础下学Python 要有方向的努力！！！《很重要》 还是那句话基础不牢地动山摇！！！","link":"/2020/02/06/Python%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/"},{"title":"SC_H版本学习日志-01","text":"SpringCloud-H版前言 在这个被疫情狂抽的2020年，我同时也需要去对面试做很大的准备，为了我的OpenResourcesProject，我同时也准备将我的项目中插入如火如荼的微服务框架—-SpringCloud 所以目前打算将我们的SpringCloud进行学习,这是第一章 同时要做出我的学习笔记！！！也就是之后系列篇 希望有什么不正确——&gt;请批评指正! 聊聊SpringCloud现况 对于Spring家的SpringCloud现在也只是维护了 所以我们的alibaba对其我们的SpringCloud，相当于做出了二次的开发并进行一系列的维护，也就是我们的SpingCloud-alibaba 开始ok 我们聊聊版本问题 对于我们在使用SpringCloud作为开发时，我们配套的肯定是我们的SpringBoot，有时候我们在选择版本时，先且不提我们SpringCloud用的是最新版的，但是如果配套的SpringBoot用的是2.0以下的 所以我们Spring官方明确指出，我们再用SpringCloud不管是哪个版本时，都是由对应的SpringBoot，有时候不对应还可能发生报错——看图 所以，我们在使用依赖或者是其他的框架时，特别注意版本的问题 Cloud版本那点事 我们SpringCloud的版本命名的时候，为了避免冲突（懒），之后使用伦敦地铁站的名字做命名，从AZ进行的排序进行迭代 我们看看dubbo和SpringCloud的区别 让我们看看详细的服务区别 分析 可以看的出来dubbo在对于SpringCloud来讲，我们的SpringCloud就显得更加的胖！哈哈哈，对东西多嘛 但是我们要知道dubbo和SpringCloud所面向的解决问题是不一样的，dubbo始终是一个RPC框架，而我们的SpringCloud是我们的微服务一站式解决方案，类似于拿包入住就完事了，这里面就不追求细节了哈，这里贴出细节的帖子 复盘一下SpingCloud使用过的组件现况对各个组件的现况 服务注册中心 Eureka（停止更新）——但是和SpringCloud配合使用 Zookeeper Cousul（Go语言开发） Nacos（alibaba）——目前趋势 服务调用 Ribbon 维护中 LoadBalancer 因为Ribbon的原因，spring自己正在研发 服务降级 Hustix 服务网关 Zuul Zuul2 gateway spring公司 服务配置 Nacos alibaba开发 Config 之前使用Spring的config…… 服务总线 Nocos alibaba开发 Bus 开发团队以崩，开发人员跳槽 我们这个最终SpringCloud用到的组件 服务治理：Eureka 负载均衡：Ribbon 容错保护：Hystrix 服务调用：Zuul 发布配置中心：Config","link":"/2020/05/25/SC-H%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-01/"},{"title":"linux终端常用的命令","text":"前言​ 最近在学linux,同时整理出来些在终端常用的命令（对于文件和目录还有压缩等等） 小Demo Clear：清除当前终端所有消息 Pwd：显示当前所在目录**** 如果说没有权限时—前面加上sudo（用管理员身份运行此命令） 递归:包括全部的文件夹以及该文件夹里的所有目录 正文—— 一．目录跳转 ​ cd usr 切换到该目录下usr目录 ​ cd ../ 切换到上一层目录 ​ cd / 切换到系统根目录 ​ cd ~ 切换到用户主目录 ​ cd - 切换到上一个所在目录 ​ ls 查看目录 ​ ls -a 查询出所有文件目录（包括隐藏的目录） ​ la -l （同== ll（小写L））可以查看所有文件及目录的所有详细信息（包括时间..等等） ​ 二．文档目录的操作 mkdir 文件名 模糊查找文件 ​ find -name ‘你要查找的文件夹’(注意要加‘ 单引号 和 *) 修改文件夹名称—（同时可以对压缩包目录修改名称） ​ mv ‘就文件夹名称’ ‘新文件夹名称’ 4.删除文件 ​ Rm -f 文件夹或目录 5.移动目录位置 ​ Mv ‘旧文件夹名称’‘旧文件夹新目录‘ 拷贝目录 ​ Cp -r 目录名称 目录拷贝的目标位置 ​ Cp -rf 目录名称 目录拷贝的目标位置（cp递归复制所有文件以及目录） 三．对于CentOS系统操作 ​ reboot 立刻重启 ​ shutdown –r now 立刻重启 ​ shutdown –r 10 10分钟后重启 四．对于文本txt ​ 1.创建一个txt可编辑文件 ​ Touch 文本名.txt ​ 2.cat/more/less/tail（四种查看文档的方式） ​ cat:只能显示最后一页的内容 ​ More：more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容。 使用空格键或回车键向下翻页 “q”退出查看 ​ less：通过上下键paup来进行查看文档“q”退出 ​ tail –‘行数’可以查看第几行的内容 ​ 文档名成 tail –‘行数‘ 3.修改文档内容 ​ vim 文档名称 ​ ① ：进去后会进入命令模式—输入：（a：末尾添加 i：当前光标添加 ） ​ 3-1：退出保存文档流程 ​ ESC退出修改文档内容模式-à进入命令模式-à输入：（进行保存操作）à①保存退出 ​ 在冒号内输入wq（来进行对修改后的文档内容进行保存） ​ ② 不想保存 ​ 在冒号内输入q（取消保存） 五：压缩文件的操作命令（打包压缩同时进行） 打包压缩文件 ​ tar -zcvf 打包压缩后的文件名 要压缩的文件名称及后缀 ​ 其中：z:调用gzip来进行压缩 ​ c:打包文件 ​ v:显示运行过程 ​ f:指定的文件名 解压-压缩包 ​ Tar -xvf 要解压的压缩包名称及后缀 ​ 3．解压到目的地 ​ ①Tar -xvf 压缩文件和后缀 -c /指定的位置 ​ -c：解压到 ​ ②： unzip 要解压的解压包 -d 解压到的地址 六：搜索关键字 六：搜索关键字 1．grep 搜索目标文件中的字符的行,来进行显示 ​ grep 字符 目标文件 七：管道命令 ​ 命令： | ​ 理解: 将上一次命令的输出作为本次命令的输入 八：进程命令 ps -ef（查看系统的进程） kill -9 结束进程的id（强制结束进程）","link":"/2020/02/12/linux%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"title":"关于java的垃圾处理机制","text":"首先说java的垃圾回收机制 简述垃圾回收机制 在java中程序员不用去显示性的去释放一个对象的内存，而是由虚拟机去自行执行 在jvm中，垃圾回收是低优先级的，所以不会在一般的情况下去运行，而实在jvm空闲的时候或者是堆空间满了的时候，才会触发执行 可以通过可达性的方式来对没有引用的对象进行一个垃圾处理的行为 缺点 java的垃圾回收机制是自动化的，可控性很差，有时会出现内存溢出的情况 再说说—java是如何确定哪些对象应该进行回收 对象被回收的两个经典算法 引用计数法 就是用来记录对象被 引用 的次数 实现方式 给对象添加上一个引用计数器， 当该对象被调用时，我们的计数器+1， 当该引用失效时，我们的计数器就会-1，当 某一个对象的引用计数器为0时，那就说明表示这个对象没有人进行引用，那就意味着它是一个失效的垃圾对象，就会被GC处理进行回收！ 缺点 这种简单的算法jvm并没有进行使用，原因是她不能解决对象间相互调用引用的问题 假设有A和B两个对象之间互相引用，也就是说A对象中的一个属性是B，B中的一个属性时A,这种情况下由于他们的相互引用，从而是垃圾回收机制无法识别 可达性分析算法 通过判断对象的引用链是否可达来进行决定对象是否进行回收 实现方式 从离散数学中的图论引入的，我们会把程序看作一张图 通过一系列的名为GC Roots的对象作为起始点 从这些节点开始向下搜索，搜索所走过的路径成为引用链 当我们一个对象到我们的GCRoot没有任何的引用链进行连接时（就是从GCRoot到这个对象不可达） 则证明此对象时不可用的，就会进行GC处理 再说说- 什么时候进行回收 在CPU空闲的时候进行回收 在堆空间储存满了之后 主动调用System.Gc()后尝试进行回收 如何回收—回收工作原理 也就是说的垃圾收集的算法 标记–清除算法（最基础的一种算法） 实现步骤 一个步骤也就是标记出需要回收的对象 标记完成后就进行同一个回收掉那些带有标记的对象 缺点 空间问题 当我们标记后进行清除后，会产生大量不连续的内存碎片 再分配 当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而造成内存空间浪费 复制算法 实现步骤 我们通过将可用的内存按容量划分为大小相等的两块，每次只去使用其中的一块 但我们这一块的内存用完了，就将还存活着的对象复制到另一块的内存上面 然后再将已使用过的内存空间一次清理掉，这样使得每次都是对其中的一块进行内存回收GC 缺点 在对其对象存活率较高时就要执行较多的复制操作时，我们的效率就会降低 更关键的是—–浪费了一半的空间 标记整理算法 实现步骤 对其需要回收的对象进行标记 然后对其标记的回收对象进行回收 与标记清楚算法进行比较 标记清楚算法仅对不存活的对象进行处理，剩余存活对象不做任何处理，造成内存碎片 而标记整理算法，不仅对不存活的对象进行处理，同时还对剩余的存活对象进行整理，重新整理 so 不会产生内存碎片 分代收集算法 理解 这种算法是一种比较智能的算法，也就是现在jvm使用最多的一种算法 算法策略 他会在具体的场景自动选择以上三种算法进行垃圾对象回收 垃圾回收的各个场景和相应回收策略","link":"/2020/04/10/%E5%85%B3%E4%BA%8Ejava%E7%9A%84%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"title":"maven初识","text":"maven&emsp;&emsp;随着时间的磨逝，我离我的职业生涯有更进了一步，最近开整了maven这个爸爸，来进行整理我的项目，使我的项目更加的整齐，同时我也可以同过maven的分模块进行编译我们java后端的三个老大哥，接下来分享一下如何安装以及去使用分模块的maven &emsp;一.安装&emsp;&emsp;&emsp;1：需要准备的东西&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;① JDK &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;②IDEA（以最智能的IDEA为主题） &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;③Maven程序安装包 &emsp;&emsp;&emsp; 2. 前往https://maven.apache.org/download.cgi下载最新版的Maven程序： &emsp;&emsp;&emsp; 3.将文件解压到D:\\Program Files\\Apache\\maven目录下: &emsp;&emsp;&emsp;&emsp; 4.新建环境变量MAVEN_HOME，赋值D:\\Program Files\\Apache\\maven &emsp;&emsp;&emsp;&emsp; 5.编辑环境变量Path，追加%MAVEN_HOME%\\bin; &emsp;&emsp;&emsp;&emsp; 6.至此，maven已经完成了安装，我们可以通过DOS命令检查一下我们是否安装成功： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这样maven的环境就ok了 &emsp;二.创建maven项目&emsp;&emsp;&emsp;&emsp; 1.选择webapp骨架 &emsp;&emsp;&emsp;&emsp;2.配置maven 的GAV &emsp;&emsp;&emsp;&emsp;3.配置你的本地的maven库 &emsp;&emsp;&emsp;3.配置你的本地的maven库 &emsp;&emsp;&emsp;&emsp;4.最后一步———-&gt;进行false，创建完成 ###&emsp;三.你的maven项目全部文件解析(这个md没有编译过来布吉岛为什么) &emsp;四.maven多模块思想&emsp;&emsp;&emsp;&emsp;1.概念！ &emsp;&emsp;&emsp;&emsp;&emsp;继承：创建一个parent工程将所需的依赖都配置在pom中 &emsp;&emsp;&emsp;&emsp;&emsp;聚合：聚合多个模块运行 &emsp;&emsp;&emsp;&emsp;2.流程 &emsp;&emsp;&emsp;&emsp;&emsp;2-1：1. 需求拆分 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Dao service（zip） web &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;何为继承：继承就是为了消除重复 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;何为聚合：项目开发通常是分组模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行 &emsp;五，创建步骤&emsp;&emsp;&emsp;1.创建父工程 ​ &emsp;&emsp;&emsp;&emsp;2.将父工程发布至仓库 ​ &emsp; &emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 3.创建dao子模块(各模块只放和自己相关代码注意：选择骨架直接下一步！来进行编译子模块) &emsp;&emsp;&emsp;&emsp; 4.测试 &emsp;&emsp;&emsp;&emsp; 上图报错的解决办法（将新建的模块 调至一样的JDK版本） &emsp;&emsp;&emsp;&emsp;5.发布模块至本地仓库 ) &emsp;&emsp;&emsp;&emsp;6.创建Biz子模块（注意：选择骨架直接下一步！来进行编译子模块） &emsp;&emsp;&emsp;&emsp;7.创建Web模块 &emsp;&emsp;&emsp;&emsp;&emsp;7-1 .同时右击创建 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;7-2.选择web-app的骨架来进行创建 &emsp;附：maven管理的SSM项目的pom.xml文件解析&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project()xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目解释--&gt; &lt;groupId&gt;cn.popdemo&lt;/groupId&gt; &lt;artifactId&gt;maven_Demo01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt;​​ maven_Demo01 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&apos;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!--项目配置版本--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt;​​ &lt;dependencies&gt; &lt;!--test测试的包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet-api的包（httprequest和respones中里使用）--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--2. SpringDAO层依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--springWeb的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis整合spring的适配包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库驱 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!--EL表达式--&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl页面的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;maven_Demo01&lt;/finalName&gt; &lt;resources&gt; &lt;!--指定xml文件位置--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*/.xml&lt;/include&gt; &lt;/includes&gt;​ false &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lockdown plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- seehttp://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!-- tomcat插件控制 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!--端口控制--&gt; &lt;port&gt;8060&lt;/port&gt; !--项目路径控制意味着http://localhost:8080/abc-- &lt;path&gt;/abc&lt;/path&gt; &lt;!--编码--&gt;UTF-8 &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- maven插件控制 --&gt; &lt;plugin&gt;org.apache.maven.plugins maven-compiler-plugin 3.1 &lt;configuration&gt;1.8 1.8 utf-8 &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; s`","link":"/2020/02/25/maven%E5%88%9D%E8%AF%86/"},{"title":"关于爬虫的流程和原理","text":"一． 爬取数据流程（Reptile） 1.在网页中找到类似于url=’http://www.7799520.com/api/user/pc/list/search?marry=1&amp;page=9' ​ 这种的网站会给我们返回一个类似于元组的数据来进行 2.requests.get(“地址”) 这个后的get是通过你当前网页的提交方式来进行决定 3.通过“键”找到对应的值来获取到自己想要的数据 4.你拿到的值是“字典“格式，所以当你在放入文档时必须要转换为集合的格式 123456789101112131415item = [ dat.get('userid'), dat.get('province'), dat.get('city'), dat.get('height'), dat.get('username'), dat.get('monolog'), ] 4-1：使用更快捷更ok 的方法 ​ //这里的*也可以称之为解包，也就是去除 [ ] 这个外壳来获取到值 Item = [*dat.value] save_test = (Str(item)）//转换为Str格式，之后进入传入文档 二．将爬取的数据放置在文档内 1.通过函数的方式进行获取到值， defsave_test(dat): 然后with也就是操作系统文档，然后不使用时，自动close​ withopen(‘DemoByJson.test’,’a’,encoding=’utf-8’) as f:​ f.write(dat+”\\n”) 2 ．最重要的“点” 12345if __name__ == '__main__': jsondata = getJson() param(jsondata) 你不是使用这个判定系统不会进入你的函数内 1If __name__ == '__main__': 这里的意思是：​ 当你当前这个py文件进行编译时，也就是当前的name已经改编为main，也就是你当前这个文件编译中！！！！","link":"/2020/02/10/%E5%85%B3%E4%BA%8E%E7%88%AC%E8%99%AB%E7%9A%84%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/"},{"title":"数据结构之二叉查找树和红黑树","text":"二叉查找树和红黑树 首先我们搞清楚什么是数据结构 Clifford A.Shaffer在《数据结构与算法分析》一书中的定义是 数据结构是 ADT（抽象数据类型Abstract Data Type） 的物理实现。 白话文 是相互之间存在一种或多种特定关系的数据元素的集合` 二叉查找树 什么是二叉查找树 对于二叉树中的每个节点X，它的左子树中所有项的值都小于X中的项，它的右子树中所有项的值大于X中的项。这样的二叉树是二叉查找树。 特点 当前节点的左子节点都是小于当前节点的（前提是左子节点不为空）； 当前节点的右子节点都是大于当前节点（前提是右子节点不为空）； 其他的左右子树也分别为二叉查找树； 缺点 前提 假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12： 当我们再连续的插入连续的递减的key（7，6，5，4，3）时，我们的二叉树就成一下这个样子 对，我们的二叉树变成了瘸子 so，我们可以直接看到这样的二叉树变得非常的不平衡，这也就延伸到了我们的红黑树 红黑树 什么是红黑树 加入了自平衡的二叉查找树也就是红黑树 怎么达到自平衡？？？ 1. 红黑节点变色 2. 旋转 左旋 右旋 红黑树的特征 节点是红色或者是黑色 根节点是黑色 每个叶子节点都是黑的空节点（NIL） 每个红色节点的子节点都是黑色的 每个叶子节点到根节点不能有连续的红节点 从任何一节点到其节点的叶子节点的黑色节点的数量都是相同的 红黑树节点称呼 下一章写红黑树的插入删除和查找流程—–&gt;","link":"/2020/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"title":"属于PopDemo的第一篇文章","text":"PopDemo给自己的一段话：首先庆祝自己获得第一个博客，虽然寄托在Github旗下，但是已经非常不错了 加油，继续努力！ 相信自己！你要继续学习的语言 JAVA Python(继续学习一下Scrapy框架) VUE(学习基础)给自己和来者的一句话基础不牢，地动山摇！！！","link":"/2020/02/02/%E5%B1%9E%E4%BA%8EPopDemo%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"从&#39;0&#39;到微服务框架","text":"微服务 理解 背景 从头开发的网上超市！ 当时 网站： 用户注册、登录功能 商品展示 下单 总体架构图 时间（变化）轴 故事 小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据 随着时代，用户增长，渐渐发生—— 知识点简介 抽象出公共服务 理解 也就是抽象出公用的业务能力，来做成公共服务 图 烟囱式系统 缺点 数据库成为性能瓶颈，并且有单点故障的风险。 数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。 数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整 监控—–发现故障的征兆 实现步骤 微服务架构中组件繁多，各个组件所需要监控的指标不同 比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等 因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差 so↓ 一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。 最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警 定位问题——链路跟踪 理解 通过链路跟踪的方式来对用户调用某个服务时查看所调用的全部接口或服务，另外还需要调用日志收集与存储的组件，以展示链路调用的UI组件 这里的UI组件 请查找答案 网关—权限控制，服务治理 背景 拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的 经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据…… 解决调用错误接口服务 so,微服务的调用需要一个把关的东西，也就是网关 在调用者和被调用者中间加入一层网关，每次调用都会进入权限校验，同时，网关可以作为一个提供服务接口文档的平台 使用网关的粒度 最粗力度 指整个微服务一个网关， 最细粒度 则是所有调用，不管是微服务内部，调用过着来自外部服务的调用，都要通过网关 折中方案 按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用 熔断，服务降级，限流 熔断 理解 当一个服务因为各种原因停止响应时，调用方通常会等待一段时间或者收到了错误返回 如果调用链路必将长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游（也就是基层）的响应， so 当我们多次访问一个服务失败时，我们应该熔断，标记该服务已停止工作 服务降级 背景 当下游的服务停止工作后，如果该服务并非核心业务，则上有服务应该降级，以保证核心业务不中断 实例 网上超市的下单页面有一个推荐商品凑单的功能，当该模块挂了后，只需要暂时关闭推荐功能即可 限流 当一个服务挂掉后，用户会习惯性的进行重复访问，，这导致一旦服务恢复正常很可能瞬间error so 服务里需要自我保护–也就是限流， 限流的策略有很多 当单位时间内请求次数过多，丢弃多余的请求， 考虑分区限流。仅拒绝来自产生大量请求的服务的请求 例如商品服务和订单服务都需要访问促销服务 商品服务由于代码问题发起了大量请求 促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应 总结 微服务框架 引入组件以及功能 指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码 如果让每个应用服务自己实现是非常耗时耗力的 so 基于DRY的原则，便有了我们现在如火如荼的微服务框架 将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发 自定义的功能 代码级的链路跟踪 甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态 缺点 框架更新成本很高 每次框架升级，都需要所有应用服务配合升级 当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级 so 因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范","link":"/2020/03/16/%E4%BB%8E'0'%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"},{"title":"序列化介绍和使用","text":"序列化 什么是序列化 就是把java对象储存在某一地方（硬盘,网络），也就是将对象的内容流化 两大类 序列化 将数据分解成字节流，一边存储在文件中或在网络上传输 反序列化 打开字节流并重构对象，对象序列化不仅要将基本数据类型转换成字节表示,有时还要恢复数据， 常用的序列化 java中自带的序列化技术 IOException** Serializable接口，则所有的序列化将会自动进行 Externalizable 则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量 json 定义 是一种轻量级的数据交换格式,采用与编程语言无关的文本格式 优缺点 优点 数据格式比较简单，易于读写 序列化后数据较小，可扩展性好，兼容性好 缺点 数据的描述性不乐观 Fastjson 定义 FastJson是一个java语言编写的高性能功能完善的JSON库 优缺点 优点 接口简单易用 目前java语言中最快的json库 缺点 过于注重快，而偏离了“标准”及功能性 代码质量不高，文档不全 Protobuf 定义 protobuf是可以进行跨语言的序列化机制 优缺点 优点 性能强 结构化数据存储格式（XML JSON等） 缺点 需要依赖于工具生成代码 如何进行序列化 让类实现Serializable接口 该接口是一个标志性的接口,标注该类可被序列 然后使用输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出 如果需要反序列化,则可以用一个输入流建立对象输入流,然后通过readObject方法从流中读取对象 代码 序列化User到本地 @Test public void Test01() throws IOException { //获取文件的输出流inputStream //将这个对象输出 User user1 = new User(1,\"PopDemo\",\"1234567\"); User user2 = new User(2,\"yangfan\",\"1234567\"); User user3 = new User(3,\"iu\",\"1234567\"); /** * 与这个文件的输出流进行绑定操作 * 我们利用这个对象的输出流，然后进行写一个操作 * 就可以实现对象的序列化的过程 * 建立管道 * 进行输出实体 */ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"F:/pop.txt\")); //讲类输出到管道内 oos.writeObject(user1); oos.writeObject(user2); oos.writeObject(user3); oos.flush(); oos.close(); System.out.println(\"数据已保存到本地，感谢您的使用\"); } &lt;!--￼0--&gt; transient 和 static 为什么不会被序列化的原因 transient static不会被序列化(IOException) 序列化保存的是对象的状态，静态变量数以类的状态，因此序列化并不保存静态变量。 这里的不能序列化的意思，是序列化信息中不包含这个静态成员域 但是还有一种情况会被序列化 One 当我们实现Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关","link":"/2020/04/02/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"深入红黑树查插删的流程底层,并深入操作后的自平衡","text":"红黑树的延伸 查找 因为红黑树就是平衡的二叉查找树，所以查找更不会破坏红黑树的平衡 查找方式流程 从根结点开始查找，把根结点设置为当前结点； 若当前节点为空，则返回null 若当前节点不为空，用当前的key跟查找的key进行比较 若当前的节点等于要查找的key，那就是我们要查找的目标 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2； 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2； 插入 插入的流程 查找插入的位置 插入后自平衡 具体判断位置流程 先找到插入的位置 1 .从根节点开始进行查找要进行插入的位置 2 .若根节点为空，那么插入节点作为根节点，结束 3 .若根结点不为空，那么把根结点作为当前结点； 4 .若当前节点为null,返回当前节点的父节点，结束 5 .若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。 6 .若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4； 7 .若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4； ok,插入的位置已经找到了，现在就是插入的颜色是什么—&gt;红色，理由很简单 红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。 但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡 深入插入情景 ​ 背景 嗯，插入情景很多呢，8种插入情景！但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂 深入4种插入情景（除了情景二其他都是在叶子节点上进行操作） 情景一：红黑树为空树 这个是最近简单的，我们直接将我们的插入节点作为根节点就OK，但是要注意，根节点的颜色为黑色，所以还需要将我们的节点的颜色设为黑色 流程 设为根节点 设置节点颜色为黑色 情景二：插入节点的Key已存在 插入的节点已存在，既然红黑树总是保持平衡的，插入前就是保持平衡的，那么插入的节点设置为当前节点的颜色，在将节点的值进行更新 流程 将我们插入节点（也就是背景图中的I）设置为当前节点（非插入节点）的颜色 更新当前节点的值为插入节点的值 情景三：插入节点的父节点为黑色 由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。 流程 直接进行插入 情景四：插入节点的父节点为红色 由于插入节点的颜色为红色，但是它的父节点的颜色也是红色，违反了红黑树的规范，那该父节点不可能成为根节点，所以后续的旋转操作需要祖父节点的加入 情景四又有更多的子情景，听我细细说来哈哈哈⚡ 插入情景4.1：叔叔结点存在并且为红结点 如果叔叔节点为红结点的话，那根据红黑树的规范来看，当前插入子树的红黑层数情况是黑红红，最简单的方式也就是改变颜色，后我们的红黑层数情况是红黑红 流程 将P和S设置为黑色 将PP设置为红色 把PP设置为当前插入结点 我们来进行对PP该节点的判断（因为进行插入后将PP节点又设置为红结点了） 如果PP节点是有父节点的 PP节点是黑色的 无需做任何的处理 PP节点是红色的 根据红黑树的约束，此时的红黑树已经是不平衡的，我们需要将PP节点作为插入节点进行，继续做插入操作自平衡处理，直到红黑树为止 如果PP节点已经是根节点了，根据红黑树的约束我们需要将PP节点设为黑节点 我们需要思想一个问题，我们现在的红黑层树为黑黑红，从另一个层面来讲，我们从根节点到我们的叶子节点之间的路径中，黑色节点增加了 这是唯一一种会增加红黑树黑色结点层数的情况 这又得出来一个结论—&gt;红黑树的生长是自底向上的，而和普通的二叉查找树是不同的，二叉查找树是自顶向下的 插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。 因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。 前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了 插入情景4.2.1：插入结点是其父结点的左子结点 我们需要维护红黑树自平衡的规范，两边的子树都平衡的 流程 将P设为黑色 将PP设为红色 对PP进行右旋 插入情景4.2.2：插入结点到其父结点的右子结点 跟4.2.1的情况是一样的不多说明了 流程 我们将P进行左旋，同时设为插入节点 得到了4.2.1的情况 之后我们在进行左旋，得到平衡的红黑树 插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点 该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。 插入情景4.3.1：插入结点是其父结点的右子结点 流程： 将P设为黑色 将PP设为红色 对PP进行左旋 插入情景4.3.2：插入结点是其父结点的左子结点 流程： 对P进行右旋 把P设置为插入结点，得到情景4.3.1 进行情景4.3.1的处理 插入所有的情景后，好好做功课的又会说，那上面所有的插入情况都是第一次进行插入有没有包含自下向上处理的情况吗？答案是肯定的 理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的 删除 我们先搞清楚红黑树删除的过程 一查找目标结点； 查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作； 而删除后自平衡。 当存在目标结点时，删除后就得做自平衡处理了。 删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代 ok,屏幕前的同学，请记住：深吸一口气，带好你的AirPods Pro（降噪打开），有点难的地方来喽！，尽量不要被打扰哦，记住，不会不清楚的话，拿出你们的笔记本，画着写着，一遍不会n遍，ok，开始 ok，二叉树删除节点找的替换结点有三个情景 若删除结点没有子节点，直接进行删除 若删除结点只有一个子节点，用子节点替换删除节点 若删除结点有两个子节点，那就用后继结点（大于删除结点的最小结点）替换删除结点 注意（补充说明） 情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点 那么 那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的 但是我们一般都习惯用后继节点进行替换节点进行使用，后面的所有替换情景都是以后继节点进行的， so,有一种可以进行直接发现删除结点的前继结点和后继节点 把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点—–看图 ok，介绍完删除结点找替换结点的情景后 接下来，讲一个重要的思路：删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！话很直接，我们看下面的图。在不注意其他因素的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！ 看上图，3中情景，情景之间可以互相转换，最终又到了情景1这里 讲解一下上面的这句话 删除结点用唯一的子节点作为替代结点，子节点替换为删除结点后，我们假如子节点下又有两个子节点，这个时候我们要进行切换到我们的情景三，注意：一直自顶向下，我们最后又会回到我们的情景1里（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了） 情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1 二叉树删除情景 综上所述，**删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。**有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了 ok，删除情景也搞ok了，我们就看看删除操作时的情景 是的，我们即时简化了还有9种情景，！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别，ok,我们说一下删除操作前的背景 操作背景前提 提醒 灰色代表的可能是红色，可能是灰色 R指得时删除结点的替代节点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成 ok,我们来到最难的时候，这时候不要放弃，馅饼就在前面，加油！！！ 详解9种删除操作情景 删除情景1：替换结点是红色结点 我们把替换的结点换到删除结点的位置上后，由于替换结点的颜色是红色，删除后又不会影响我们红黑树的平衡，所以直接将我们的替换结点的颜色设为删除结点就ok 流程 将替换结点的颜色换为删除结点就ok 删除情景2：替换节点是黑色结点 我们替换后倒是不需要去大致的注意连续红色的结点出现，所以我们要注意的是我们的根节点到我们的叶子节点的黑结点也就多了一个，所以要进行旋转的操作，对于情况的左旋右旋 删除情景2.1：替换结点是其父结点的左子结点 删除情景2.1.1:替换结点的兄弟结点是红结点 若兄弟结点是红结点，那它的父节点和子节点一定是黑色结点（根据约束4），不会有其他情况，所以进行处理，但是没有处理完，我们要继续深究到2.1.2.3（记住，这里的R仍然是我们的替换节点）（ 处理 将S设为黑色 将P设为红色 对P进行左旋，得到情景2.1.2.3 进行情景2.1.2.3的处理 删除情景2.1.2：替换结点的兄弟结点是黑结点（各种情况各种定） 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景 删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色（黑结点数量不同） 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1个了，然而右子树又有红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。 处理 将S的颜色设为P的颜色 将P设为黑色 将SR设为黑色 对P进行左旋 平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的另外上幅图是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil（因为R作为替换节点到树底时，这时R已经是删除结点后进行删除了，，也就是只剩SL了），所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了 删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点（借点红结点保持平衡呗） 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。 流程 将S设为红色 将SL设为黑色 对S进行右旋，得到情景2.1.2.1 进行情景2.1.2.1的处理（进行自平衡） 删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点 好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的 流程 将S设为红色 把P作为新的替换结点 重新进行删除结点情景处理 删除情景2.2：替换结点是其父结点的右子结点 好啦，右边的操作也是方向相反，不做过多说明了，相信你理解了删除情景2.1后，肯定可以理解2.2。 删除情景2.2.1：替换结点的兄弟结点是红结点 我们这样子看的话，我们删除替代节点时，我们的红黑树还是不具有平衡性的，我们先进行平衡，之后再进行平行 流程 将S设为黑色 将P设为红色 对P进行右旋，得到情景2.2.2.3 进行情景2.2.2.3的处理 删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色 流程 将S的颜色设为P的颜色 将P设为黑色 将SL设为黑色 对P进行右旋 **删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点 流程 将S设为红色 将SR设为黑色 对S进行左旋，得到情景2.2.2.1 进行情景2.2.2.1的处理 删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点 流程 将S设为红色 把P作为新的替换结点 重新进行删除结点情景处理 总结（删除总结）红黑树删除后自平衡的处理可以总结为： 自己能搞定的自消化（情景1） 自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3） 兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3） 啊，我是真的吐了，本章参考于安卓大叔的红黑树理解，但是所有的文字都是经过自己的理解敲上来的（脑子要炸掉），到这里是真的完了，现在已经是晚上的2：38了，我也该睡觉觉了，明天再复习一遍！！！","link":"/2020/05/09/%E6%B7%B1%E5%85%A5%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9F%A5%E6%8F%92%E5%88%A0%E7%9A%84%E6%B5%81%E7%A8%8B%E5%BA%95%E5%B1%82-%E5%B9%B6%E6%B7%B1%E5%85%A5%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E8%87%AA%E5%B9%B3%E8%A1%A1/"},{"title":"透析HTTPS","text":"前提 近年来,各大公司都在大力推进HTTPS的建设,Google Chorm将非HTTPS的网站例为”不安全“,苹果要求APP中使用HTTPS进行传输通信,微信小程序也要求使用HTTPS协议 ok,那为什么非要做一件事 我们先来看看HTTP HTTP(Hypertext Transfer Protocol)超文本传输协议,是一种用于分布式,协作式,超媒体信息系统的应用传输协议,可以说HTTP是当代互联网传输的基础 说说为什么会明令禁止HTTP有一个致命的缺陷,也就是内容是明文传输的,没有经过任何的加密,而这些明文经常会通过一些 wifi 路由器 运营商的一系列物理设备节点; 如果在这些节点上被进行监听,传输的内容将会完全暴露 这一攻击手法叫做MITM(Man In The Middle)中间人攻击 转载于敖丙,up主对于安全特别的痴迷,康康他举的例子 可以拿小时候上课传纸条来类比，你坐在教室靠墙的一边，想要传一句「晚上放学操场我等你」给坐在窗边的小红，中间要经过六七个人的传递。虽然你把纸条对折了一下，但是防君子不防小人，中间的所有人都可以很轻易地打开纸条看到你想要说什么。 只是看还好，如果有小刚也喜欢小红，看到你俩马上就要甜甜蜜蜜地回家了，心有不甘，换了一张纸条，改成了「晚上放学你自己回家吧，我要去网吧玩游戏」。 小红看到你要抛弃她自己去玩游戏，非常伤心，开始在纸条上质问「说好的一起回家呢，为什么要去打游戏，哼」。 在小红的纸条传回来的路上，小刚又改了纸条「你玩你的游戏去吧，我要和小刚回家」。 于是，你和小红都倍感伤心，小刚横刀夺爱，而你一头雾水。 哈哈哈,对于这样的横刀夺爱,就是不安全的!!! 回忆几年前的遍地的运营商劫持,当你访问一个本来就很正常的一个网站的时候,但是也页面上却会出现一些莫名其妙的东西,广告啊,跳转,欺骗性的红包啊等,更过分的就是本来你要下载的东西,不知不觉的下载成了其他的东西,这就是被运行商截取HTTP明文的现象 还有各大公司中的[不要连接陌生wifi],也有类似的原因,进行截取明文的例子 so为了解决HTTP使用明文传输数据不安全的现象,1994年网景公司提出了HTTPS(HyperText Transfer Protocol Secure)超文本传输协议,数据通信仍是HTTP,但是利用了SSL/TLS加密数据包 我这人喜欢”刨祖坟”也就是追究实现原理HTTPS实现原理 SSL（Secure Sockets Layer）安全套接层和TLS（Transport Layer Security）传输层安全协议其实是一套东西。 工作流程 看看HTTPS加解密的流程 用户在浏览器发送HTTPS请求（如：https://www.mogu.com/），默认使用浏览器的443端口进行连接 HTTPS需要使用一套CA数据证书，证书内会附带一个公钥Pub，同时与之对应的私钥Private留在服务器不公开 服务端收到请求后，返回配置好的包含公钥Pub的证书给客户端 客户端收到用户返回的证书后，检验合法性，主要是包括是否在有效期内，证书的域名与请求的域名是否匹配，上一级的证书是否有效(递归判断，直到判断到系统内置或浏览器配置好的根证书)，如果不匹配返回HTTPS警告，匹配成功进行下一步 客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送到服务端 服务端收到随机生成的密钥。使用与公钥配对的密钥进行解密，得到客户端真正想要的随机Key 服务端使用客户端发送的随机Key对密文进行加密，将密文返回给客户端 客户端使用随机Key对称解密密文，得到HTTP数据明文 后续HTTPS请求使用之前交换好的随机Key进行对称加解密 对称加密和非对称加密 对称加密 对称加密指的是一个密钥。用它可以对一段明文加密，加密之后也就只能用这个密钥进行解密拿到密文，如果双方都持有密钥，且天知地知你知我知，绝对不会有别人知道，那么通信安全自然是可以保证的，但是前提是你的密钥足够强 但是呢，在HTTPS的传输情境下，我们服务端实现不是到客户端是谁，你也不可能在事先不通过互联网去和一个网站的管理员都悄悄的商量哈这个密钥，同时这密钥在互联网传输的过程中，如果被别人监听到，那么我们后续的加密都是无用功 非对称加密 介绍 非对称加密有两个密钥，一个是公钥Pub，一个是密钥Private，一般公钥是用来加密的，这个时候传输过来的密文只能通过密钥来进行解密 ok 我们客户端发起服务请求，之后服务端将公钥发送过去，客户端利用公钥加密好密文，发送到服务端，之后服务端用自己的密钥进行解密 但是呢，我们服务端要向客户端发送消息，如果要用自己的公钥进行加密发送后，客户端是没有私钥进行解密查看的，如果用私钥进行加密，那客户端可以拿之前的传输过来的公钥进行解密查看，但是之前的公钥就在互联网上进行传输过来，很可能已经有人拿到了，这个非对称也是不能满足的 注意，严格来讲，私钥并不能用来加密，只能用作签名使用，这是由于密码学中生成公钥私钥时对不同变量的数学要求是不同的，因此公钥私钥抵抗攻击的能力也不同，在实际使用中不可互换。签名的功能在HTTPS里也有用到，下文中会说明。 只有一组公钥私钥只能去保证单程的加解密，那如果我们准备两组公钥私钥呢，是不是就可以解决这个问题 服务端由非对称的公钥A1，私钥A2； 客户端由非对称的公钥B1，私钥B2； 客户端由服务端发起请求，服务端将公钥A1返回给客户端 浏览器收到公钥A1,将自己保存的公钥B1发送给服务端 之后浏览器所有向客户端发送的数据，使用公钥B1进行加密客户端可以使用B2进行解密； 客户端所有向服务端发送的数据，使用公钥A1进行加密，服务端可以使用私钥A2进行解密 ok,此时传输方向的数据都是经过非对称加密，都能保证安全性，那么为什么不采用这种方案呢？ちょっと待って最主要的原因是非对称加密耗时要远大于对称加解密，对性能有很大损耗，大家的使用体验很差so我们才会最终选用了上文介绍的非对称加密+对称加密的方案，再反过来看一下 服务端有非对称的加密的公钥A1，私钥A2 当客户端发送请求后，我们的服务端将公钥A1返回到客户端 客户端随机生成一个对称加密的密钥K，用公钥A1进行加密发送到服务端 服务端使用A2进行对应的解密，拿到客户端的密钥K，此时就完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题 之后双方都可以使用密钥K进行对称加解密 现在看起来是一个完美的方案，但是呢安全吗？？？CA颁发机构依然考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥 当服务端向客户端返回公钥A1的同时，中间人可以替换成自己的B1公钥给浏览器 而浏览器此时一无所知，傻乎乎的使用公钥B1加密了密钥发送出去，又被中间人截获，中间人利用自己的私钥B2解密，得到密钥K，在使用服务端的公钥A1进行加密传送给服务端，完成通信链路，而服务端和客户端毫无感知 出现这一问题的核心原因也就是客户端无法确认收到的公钥是不是服务端发来的，为了解决这一问题，也就是引入了一个公信机构，也就是我们CA机构 服务端在使用HTTPS之前，要去经过认证的CA机构去颁发一份数字证书，里面包括了证书持有者，证书有效期，公钥等信息，服务端将证书发送给客户端，客户端进行校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作n 但是呢，如果中间人再聪明一点，之改动了证书的公钥部分，客户端也不能使用证书信息来进行对公钥的正确认证，所以就要采取一些防伪技术 前文提过，在非对称加密中，我们的私钥是用来解密的，公钥是用来加密的，那私钥干的活只有解密吗其实对于私钥的用处还有数字签名，其实这就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。具体过程如下 CA机构拥有自己的一对公钥和私钥 CA在颁发证书时对证书铭文信息进行了哈希 哈希后又利用私钥进行加签 明文数据和数字签名传递给客户端 客户端得到证书，分解成明文部分Text和数字签名Sig1 用CA证书中的公钥进行解签,得到Sig2（由于CA是公信身份，所以会在系统或浏览器中内置CA机构的公钥和证书） 再使用证书中的hash算法对明文部分Text进行哈希后得到H 之后通过计算得到的哈希值T与解签后的Sig2相等的话，表示证书可信，没有被篡改 说实话这里有一点难理解 非对称加密的签名过程是 私钥将一段进行加签，之后将我们的签名部分和消息本身一起发送给对方 收到消息后对签名部分利用公钥验签，如果验签出来的内容和消息本身一致，表明消息没有被篡改 在这个过程中，系统或浏览器中内置的CA机构的证书和公钥成为了至关重要的环节，这也是CA机构公信身份的证明，如果系统或浏览器中没有这个CA机构，那么客户端可以不接受服务端传回的证书，显示HTTPS警告 实际上CA机构的证书是一条信任链，A信任B，B信任C 总结HTTPS的出发点就是解决HTTP传输信息时被篡改和监听的问题 为了兼容性能和安全，之后加入了对称加密和非对称加密的方案 为了保证公钥在传输的过程中不被篡改，又使用了非对称加密的数字签名功能，借助CA机构和系统根证书的机制，保证了HTTPS证书的公信力 ok，本文参考自敖丙的HTTPS透析 最近呐，经历了好多事情，改变了我好多，让我更加的有信心的迈向大厂的信心!!!","link":"/2020/05/25/%E9%80%8F%E6%9E%90HTTPS/"},{"title":"集群&#x2F;分布式&#x2F;SOA","text":"集群 维基百科 计算机集群简称集群是一种计算机系统，它通过一组松散集成的计算机软件和/或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多 特点 通过多台计算机来完成一个工作，达到更高的效率 两机或多机内容和工作过程完全相同，如果一台死机还有另外的可以进行使用 白话文讲解集群（对于服务而言） 我们开发的秒杀项目里面有几种一摸一样，功能也一致的服务，这种情况叫做集群 背景讲解 当我们的项目在一台差不读配置的服务器上部署，当有一天我们的服务器开始大批量的进入访问量，这个时候我们服务器的访问变得很慢，所以PopDemo准备再买一台服务器，将我们的项目部署到上面 特点 两个服务器同时去运行同一个项目 好处 我们之前是一个服务器而言，所有的压力都在这一个服务器上面，当我们两个服务器同时去部署这个项目时，分担了访问的压力，大大的提高了我们的质量 集群：同一个业务，部署在多个服务器上(不同的服务器运行同样的代码，干同一件事) 分布式 维基百科 分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。组件之间彼此进行交互以实现一个共同的目标 白话文理解 当我们的项目部署到两个服务器上后我们发现，访问量还是不停的上增，我们的访问也愈来愈慢，不可能再去买一个服务器跑吧，我们开始追究项目问题，当我们发现所有的服务都在一个tomcat上运行着，这么高的访问量怎么弄的快 解决 我们可以直观的发现有些服务的访问量是很低的，所以我们打算抽象独立出来 将我们访问量高的服务拿配置好一点的服务器来跑 访问量低的我们拿差的服务器装着 好处 资源合理利用 我们访问量高的使用高配置的服务器吗 耦合度降低 我们将我们模块抽象独立出来，大大的降低了我们代码之间的耦合度 特点 我们将项目的服务进行模块化的拆分，之后再组合起来就是个完美的系统 好处 拆分成模块化后，我们模块之间的各做各的事情，便于扩展 高吞吐量 某个任务需要一个机器运行10个小时，将该任务用10台机器的分布式跑(将这个任务拆分成10个小任务)，可能2个小时就跑完了 分布式：一个项目拆分为多个子模块，部署在不同的服务器上（不同的服务器，运行不同的代码，干着同一件事） 集群/分布式集群和分布式不冲突，还可以有分布式集群​ 现在PopDemo的公司规模变大了，有5个小伙子写Java，4个小伙子写前端，2个小伙子做测试，1个小伙子做DBA。 Java，前端，测试，DBA的关系看作是分布式的 5个Java看作是集群的(前端，测试同理)… 微服务/分布式/SOA​ 我认为分布式和微服务/SOA这三个是差不多的，只不过微服务更+1吧 2.CAP理论前言​ 对于我们上面分布式概念我们已经很大的清楚，简答的理解也就是说，将一个业务拆分为多个子业务，一个业务部署在不同的的服务器上 一个子业务称之为一个结点 首先我们看一下CAP是什么，他们分别代表着什么 C：数据一致性（consistency） 所有的数据都拥有数据的最新版 A：可用性（availability） 数据具有高可用性 P：分区容错性（partition-tolerance） 容忍网络出现分区，分区之间的网络不可达 下面是三个节点（它们是集群的）此时的三个节点可以相互通信 由于我们的系统是分布式的，节点之间的通讯交流是通过我们的网络来进行的。只要是分布式系统，那就有可能发生一种情况：因为一些故障，使得我们节点之间不能进行通信了，整个网络也就分成了几部分 数据分散在不连通的区域中，这叫分区 出现网络分区后，ok，现在有一个用户请求注册，请求打了进来 这个时候我们有几个抉择 如果允许当前用户进行注册，此时记录数据的是由节点一和节点二或者是节点二和节点三，因为节点一和节点三的之间是不通信的 这种情况也就是选择了可用性（availability），同时抛弃了数据一致性（consistency） 如果不允许当前用户进行注册（也就是要等节点一和节点三回复通信），节点一和节点三以但通信，我们也就直接的保证了数据的一致性 这种情况也就抛弃了可用性（availability），选择了数据一致性（consistency） ok，再梳理一下CAP理论一般来说我们的分布式系统，P：分区容错性（partition-tolerance）这个是必须的，是具有一定的客观性存在性 CAP是无法完全兼顾的，在上面举的例子中，我们可以选择Ap，也可以选择CP，但是一定要注意，不是说选择了AP，C就直接完全抛弃了，不说选了CP，A也就完全抛弃了 在CAP中C所表示的一致性是强一致的（每个节点的数据都是最新版的），其实一致性还有其它版本的 弱一致性 对于强一致性而言，它不能保证总能得到最新的值 最终一致性 放宽对其时间的要求，在被调完成操作响应后的某个时间点，被调多个节点的数据最终达成一致 参考至：JAVA3y","link":"/2020/05/17/%E9%9B%86%E7%BE%A4-%E5%88%86%E5%B8%83%E5%BC%8F-SOA/"}],"tags":[{"name":"LomBok","slug":"LomBok","link":"/tags/LomBok/"},{"name":"MQ","slug":"MQ","link":"/tags/MQ/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"微服务-SpringCloud","slug":"微服务-SpringCloud","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1-SpringCloud/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"java垃圾处理机制","slug":"java垃圾处理机制","link":"/tags/java%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"数据结构和算法","slug":"数据结构和算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"HTTPS通信","slug":"HTTPS通信","link":"/tags/HTTPS%E9%80%9A%E4%BF%A1/"}],"categories":[{"name":"组件","slug":"组件","link":"/categories/%E7%BB%84%E4%BB%B6/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"构建项目","slug":"构建项目","link":"/categories/%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"name":"日志","slug":"日志","link":"/categories/%E6%97%A5%E5%BF%97/"},{"name":"计算机相关原理","slug":"计算机相关原理","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"}]}